import tdt
import os
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import scipy as sy


# Define function to calculate SEM
def sem(arr):
    return np.std(arr, axis=0) / np.sqrt(len(arr))

# Define function to find lick bouts
max_interval = 1.0
def identify_and_sort_lick_bouts(lick_timestamps, max_interval):
    bouts = []
    current_bout = []
    for i in range(len(lick_timestamps)):
        if not current_bout:
            current_bout.append(lick_timestamps[i])
        else:
            if lick_timestamps[i] - current_bout[-1] <= max_interval:
                current_bout.append(lick_timestamps[i])
            else:
                bouts.append(current_bout)
                current_bout = [lick_timestamps[i]]
    if current_bout:
        bouts.append(current_bout)
    # Calculate the length of each bout
    bout_lengths = [(len(bout), bout) for bout in bouts]
    # Sort bouts by their length
    sorted_bouts = sorted(bout_lengths, key=lambda x: x[0])
    return sorted_bouts

#folder = '/Users/kristineyoon/Library/CloudStorage/OneDrive-Vanderbilt/D1D2_FiberPhotometry/New/NewRig'
#folder = '/Users/kristineyoon/Library/CloudStorage/OneDrive-Vanderbilt/D1D2_FiberPhotometry/'
folder = '/Users/kristineyoon/Library/CloudStorage/OneDrive-Vanderbilt/D1D2_FiberPhotometry/New/Water'
#mice=['6364','6365','6605','6361']
#mice = ['7098','7099','7107','7108']
mice = ['6364']
files = os.listdir(folder)
files.sort()
print(files)

avgcuetrace_dict = {}
avgresptrace_dict = {}
avglevertrace_dict = {}
avgflicktrace_dict = {}
avglickbouttrace_dict = {}
lickbouttracedict ={}      
timerange_cue = [-2, 5]
timerange_lever = [-2, 10]
timerange_lick = [-2, 12]
cue_time = 20
lick_time= 10

for mouse in mice:
    mouse_dir = os.path.join(folder, mouse)
    Dates = [x for x in os.listdir(mouse_dir) if x.isnumeric()]
    Dates.sort()
    for date in Dates:
        date_dir = os.path.join(mouse_dir, date)
        data = tdt.read_block(date_dir)
        
        df = pd.DataFrame()
        df['Sig465'] = data.streams._465B.data
        df['Sig405'] = data.streams._405B.data
        df['Dff'] = (df['Sig465']-df['Sig405'])/df['Sig465']
        fs = round(data.streams._465B.fs)

        split1 = str(data.epocs).split('\t')
        y = []
        for elements in split1:
            x = elements.split('\n')
            if '[struct]' in x:
                x.remove('[struct]')
            y.append(x)
        z= [item for sublist in y for item in sublist]

        fp_df = pd.DataFrame(columns=['Event','Timestamp'])
        events = ['Press', 'Licks']
        epocs = ['Po6_','Po4_']
        
        for a, b in zip(events, epocs):
            if b in z:
                event_df = pd.DataFrame(columns=['Event','Timestamp'])
                event_df['Timestamp'] = data.epocs[b].onset
                event_df['Event'] = a
                fp_df = pd.concat([fp_df, event_df])
        
        
        track_cue = []
        track_lever = []
        track_licks = []
        track_to = []
        latency= []
        leverpermice = []
        for i in range(len(fp_df)):
            if fp_df.iloc[i,0] == 'Cue':
                track_cue.append(fp_df.iloc[i,1])
            if fp_df.iloc[i,0] == 'Press':
                track_lever.append(fp_df.iloc[i,1])
            if fp_df.iloc[i,0] == 'Licks':
                track_licks.append(fp_df.iloc[i,1])
            if fp_df.iloc[i,0] == 'Timeout Press':
                track_to.append(fp_df.iloc[i,1])

            
        ########################## CUE ALIGNMENT ##########################    
        cuestolevers={}
        for i in range(len(track_cue)):
            for k in range(len(track_lever)):
                if track_lever[k]- track_cue[i]<= cue_time and track_lever[k]- track_cue[i]>0:
                    cuestolevers[track_cue[i]]=track_lever[k]
                    
        align_cue = []
        
        for i in range(len(track_cue)):
            cue_zero = round(track_cue[i] * fs)
            cue_baseline = cue_zero + timerange_cue[0] * fs
            cue_end = cue_zero + timerange_cue[1] * fs
            rawtrial = np.array(df.iloc[cue_baseline:cue_end,2])
            align_cue.append(rawtrial)
        
        ### DOWNSAMPLING
        N = 100
        sample_cue=[]
        for lst in align_cue: 
            small_lst = []
            for i in range(0, len(rawtrial), N):
                small_lst.append(np.mean(lst[i:i+N-1])) # This is the moving window mean
            sample_cue.append(small_lst)
        zscore_cue = []
        
        ### ZSCORE
        baselinedict = {}
        for i in range(len(sample_cue)):
            trial = sample_cue[i]
            zb = np.mean(trial[0:round((-timerange_cue[0]*fs/N))])
            zsd = np.std(trial[0:round((-timerange_cue[0]*fs/N))])
            baselinedict[track_cue[i]] = zb, zsd
            trial = (trial - zb)/zsd
            zscore_cue.append(trial)

        ### TRACES
        fptrace_df = pd.DataFrame()
        for i in range(0,10):
            fptrace_df[i]=zscore_cue[i]

        working_lst = []
        for i in range(len(fptrace_df)):
            avg_at_time = np.mean(fptrace_df.loc[i,:])
            working_lst.append(avg_at_time)
        avgcuetrace_dict[mouse,Dates.index(date)]=working_lst
        
        ##PEAK HEIGHT

        from scipy.signal import find_peaks

        for i in range(len(zscore_cue)):
            x = zscore_cue[i][round((-timerange_cue[0]*fs/N)):round(((1-timerange_cue[0])*fs/N))]
            aoi = zscore_cue[i][round((-timerange_cue[0]*fs/N)):]
            peaks, _ = find_peaks(x, prominence=(.4,None), height=(1,None),width=(1,None))
                                  #,width=(5,20), height=(1,10))
            plt.plot(x, color='lightblue')
            if len(peaks) >0:
                plt.plot(peaks[0], x[peaks[0]], "x", color='orange')
            plt.plot(np.zeros_like(x), "--", color="gray")
            plt.show()

        ##### RESPONDING CUES ALIGNMENT ONLY #####
        respondingcue = []
        for cuetime, traces in zip(track_cue, sample_cue):
            for cue,lever in cuestolevers.items():
                if cuetime == cue:
                    zb = baselinedict[cue][0]
                    zsd = baselinedict[cue][1]
                    newtrial = (traces - zb)/zsd
                    respondingcue.append(newtrial)

        ### TRACES
        fptrace_df = pd.DataFrame()
        if len(respondingcue) > 0:
            for i in range(len(respondingcue)):
                fptrace_df[i]=respondingcue[i]
    
            working_lst = []
            for i in range(len(fptrace_df)):
                avg_at_time = np.mean(fptrace_df.loc[i,:])
                working_lst.append(avg_at_time)
            avgresptrace_dict[mouse,Dates.index(date)]=working_lst
            
        ##### RESPONDING CUES ALIGNMENT ONLY #####
        nonrespondingcue = []
        for cuetime, traces in zip(track_cue, sample_cue):
            for cue,lever in cuestolevers.items():
                if cuetime != cue:
                    zb = baselinedict[cue][0]
                    zsd = baselinedict[cue][1]
                    newtrial = (traces - zb)/zsd
                    nonrespondingcue.append(newtrial)
        ### TRACES
        fptrace_df = pd.DataFrame()
        if len(respondingcue) > 0:
            for i in range(len(respondingcue)):
                fptrace_df[i]=respondingcue[i]
    
            working_lst = []
            for i in range(len(fptrace_df)):
                avg_at_time = np.mean(fptrace_df.loc[i,:])
                working_lst.append(avg_at_time)
            avgresptrace_dict[mouse,Dates.index(date)]=working_lst
            
        ##### LEVER ALIGNMENT #####
        align_lever = []
        
        for i in range(len(track_lever)):
            lever_zero = round(track_lever[i] * fs)
            lever_baseline = lever_zero + timerange_lever[0] * fs
            lever_end = lever_zero + timerange_lever[1] * fs
            trial = np.array(df.iloc[lever_baseline:lever_end,2])
            align_lever.append(trial)

        ### DOWNSAMPLING
        sample_lever=[]
        for lst in align_lever: 
            small_lst = []
            for i in range(0, len(trial), N):
                small_lst.append(np.mean(lst[i:i+N-1])) # This is the moving window mean
            sample_lever.append(small_lst)
            
        zscore_lever = []
        for levertime, trace in zip(track_lever, sample_lever):
            for cue,lever in cuestolevers.items():
                if levertime == lever:
                    zb = baselinedict[cue][0]
                    zsd = baselinedict[cue][1]
                    newtrial = (trace - zb)/zsd
                    zscore_lever.append(newtrial)
                    
        ### TRACES
        fptrace_df = pd.DataFrame()
        if len(zscore_lever) > 0:
            for i in range(len(zscore_lever)):
                fptrace_df[i]=zscore_lever[i]
    
            working_lst = []
            for i in range(len(fptrace_df)):
                avg_at_time = np.mean(fptrace_df.loc[i,:])
                working_lst.append(avg_at_time)
            avglevertrace_dict[mouse,Dates.index(date)]=working_lst

        ################## FIRST LICK ALIGNMENT ################3
        track_flicks = []
        firstlicks = []
        for press in track_lever:
            lickyes = np.array(track_licks) > press
            firstlicktime = np.where(lickyes == True)
            if len(firstlicktime[0]) > 0:
                firstlicks.append(firstlicktime[0][0])
        firstlicks = list(set(firstlicks))
        for index in firstlicks:
            track_flicks.append(track_licks[index])

        cuestolicks={}
        for i in range(len(track_cue)):
            for k in range(len(track_flicks)):
                if track_flicks[k]- track_cue[i] <= (cue_time + lick_time) and track_flicks[k]- track_cue[i]>0:
                    cuestolicks[track_cue[i]]=track_flicks[k]
                    
        align_flick = []
        
        for i in range(len(track_flicks)):
            flick_zero = round(track_flicks[i] * fs)
            flick_baseline = flick_zero + timerange_lick[0] * fs
            flick_end = flick_zero + timerange_lick[1] * fs
            trial = np.array(df.iloc[flick_baseline:flick_end,2])
            align_flick.append(trial)

        ### DOWNSAMPLING
        sample_flick=[]
        for lst in align_flick: 
            small_lst = []
            for i in range(0, len(lst), N):
                small_lst.append(np.mean(lst[i:i+N-1])) # This is the moving window mean
            sample_flick.append(small_lst)

        zscore_flick = []
        for flicktime, trace in zip(track_flicks, sample_flick):
            for cue,lick in cuestolicks.items():
                if flicktime == lick:
                    zb = baselinedict[cue][0]
                    zsd = baselinedict[cue][1]
                    newtrial = (trace - zb)/zsd
                    zscore_flick.append(newtrial)
        
        ### TRACES
        fptrace_df = pd.DataFrame()
        if len(zscore_flick) > 0:
            for i in range(len(zscore_flick)):
                fptrace_df[i]=zscore_flick[i]
    
            working_lst = []
            for i in range(len(fptrace_df)):
                avg_at_time = np.mean(fptrace_df.loc[i,:])
                working_lst.append(avg_at_time)
            avgflicktrace_dict[mouse,Dates.index(date)]=working_lst
        
        
        ############ LICKBOUTS #################
        # Identify and sort lick bouts by length
        sorted_lick_bouts = identify_and_sort_lick_bouts(track_licks, max_interval)
        sorted2_lick_bouts=[]
        for order, value in sorted_lick_bouts:
            if order > 5:
                sorted2_lick_bouts.append(value)
        track_lickbouts=[]
        for lickbouts in sorted2_lick_bouts:
            track_lickbouts.append(lickbouts[0])
            
        ##### LICKBOUT ALIGNMENT #####
        align_lickbout = []
        
        for i in range(len(track_lickbouts)):
            lickb_zero = round(track_lickbouts[i] * fs)
            lickb_baseline = lickb_zero + timerange_lick[0] * fs
            lickb_end = lickb_zero + timerange_lick[1] * fs
            trial = np.array(df.iloc[lickb_baseline:lickb_end,2])
            align_lickbout.append(trial)
        
        ### DOWNSAMPLING
        sample_lickbout=[]
        for lst in align_lickbout: 
            small_lst = []
            for i in range(0, len(lst), N):
                small_lst.append(np.mean(lst[i:i+N-1])) # This is the moving window mean
            sample_lickbout.append(small_lst)
        
        zscore_lickbout = []
        for lickbouttime, trace in zip(track_lickbouts, sample_lickbout):
            for key, elements in baselinedict.items():
                if int(lickbouttime) > int(key) and int(lickbouttime) < int(key+cue_time):
                    zb = baselinedict[key][0]
                    zsd = baselinedict[key][1]
                    newtrial = (trace - zb)/zsd
                    zscore_lickbout.append(newtrial)
                    
        ### TRACES
        fptrace_df = pd.DataFrame()
        if len(zscore_lickbout) > 0:
            for i in range(len(zscore_lickbout)):
                fptrace_df[i]=zscore_lickbout[i]
                lickbouttracedict[mouse,Dates.index(date),i]=zscore_lickbout[i]
        
            working_lst = []
            for i in range(len(fptrace_df)):
                avg_at_time = np.mean(fptrace_df.loc[i,:])
                working_lst.append(avg_at_time)
            avglickbouttrace_dict[mouse,Dates.index(date)]=working_lst


############################################################
############################################################
############################################################
############################################################
############################################################


#### CUE ANALYSIS ####
#by session individual
plt.figure(figsize=(8,4))
for i in range(10):
    for mouse,session in avgcuetrace_dict:
        if session == i:
            plt.plot(avgcuetrace_dict[str(mouse),session],color=sns.color_palette("light:teal")[i],label=i)
plt.xticks(np.arange(0,len(zscore_cue[0])+1,len(zscore_cue[0])/(timerange_cue[1]-timerange_cue[0])), 
           np.arange(timerange_cue[0], timerange_cue[1]+1,1, dtype=int),
           rotation=0)
plt.axvline(x=len(zscore_cue[0])/(timerange_cue[1]-timerange_cue[0])*(0-timerange_cue[0]),linewidth=1, color='black')
plt.axhline(y=0, linestyle=':', color='black')
plt.legend()
plt.xlabel('Cue Onset (s)')
plt.savefig('/Users/kristineyoon/Documents/cue.pdf', transparent=True)

#by session average
session_data = {}  
for key, value in avgcuetrace_dict.items():
    mouse, session = key
    if session not in session_data:
        session_data[session] = []
    session_data[session].append(value)
mean_traces = {}
sem_traces = {}
for session, traces in session_data.items():
    mean_traces[session] = np.mean(traces, axis=0)
    sem_traces[session] = sem(traces)
plt.figure(figsize=(10, 6))
for session, mean_trace in mean_traces.items():
    sem_trace = sem_traces[session]
    plt.plot(mean_trace, color=sns.color_palette("light:teal")[int(session)+1], label=f'Session {session}')
    plt.fill_between(range(len(mean_trace)), mean_trace - sem_trace, mean_trace + sem_trace, color=sns.color_palette("light:teal")[int(session)+1], alpha=0.3)
plt.xlabel('Time (samples)')
plt.xticks(np.arange(0,len(mean_trace)+1,len(mean_trace)/(timerange_cue[1]-timerange_cue[0])), 
           np.arange(timerange_cue[0], timerange_cue[1]+1,1, dtype=int),
           rotation=0)
plt.axhline(y=0, linestyle=':', color='black')
plt.axvline(x=len(mean_traces[0])/(timerange_cue[1]-timerange_cue[0])*(0-timerange_cue[0]),linewidth=1, color='black')
plt.ylabel('Z-score')
plt.title('Average Cue-aligned Trace with SEM by Session')
plt.legend()
plt.show()

#### LEVER ANALYSIS ####
#by session individual
plt.figure(figsize=(8,4))
for i in range(10):
    for mouse,session in avglevertrace_dict:
        if session == i:
            plt.plot(avglevertrace_dict[str(mouse),session],color=sns.color_palette("light:teal")[i],label=i)
plt.xticks(np.arange(0,len(zscore_lever[0])+1,len(zscore_lever[0])/(timerange_lever[1]-timerange_lever[0])), 
           np.arange(timerange_lever[0], timerange_lever[1]+1,1, dtype=int),
           rotation=0)
plt.axvline(x=len(zscore_lever[0])/(timerange_lever[1]-timerange_lever[0])*(0-timerange_lever[0]),linewidth=1, color='black')
plt.axhline(y=0, linestyle=':', color='black')
plt.legend()
plt.xlabel('Lever Onset (s)')
plt.savefig('/Users/kristineyoon/Documents/cue.pdf', transparent=True)

#by session average
session_leverdata = {}  
for key, value in avglevertrace_dict.items():
    mouse, session = key
    if session not in session_leverdata:
        session_leverdata[session] = []
    session_leverdata[session].append(value)
mean_levertraces = {}
sem_levertraces = {}
for session, traces in session_leverdata.items():
    mean_levertraces[session] = np.mean(traces, axis=0)
    sem_levertraces[session] = sem(traces)
plt.figure(figsize=(10, 6))
for session, mean_trace in mean_levertraces.items():
    sem_levertrace = sem_levertraces[session]
    plt.plot(mean_trace, color=sns.color_palette("light:orange")[int(session)+1], label=f'Session {session}')
    plt.fill_between(range(len(mean_trace)), mean_trace - sem_levertrace, mean_trace + sem_levertrace, color=sns.color_palette("light:orange")[int(session)+1], alpha=0.3)
plt.xlabel('Time (samples)')
plt.xticks(np.arange(0,len(mean_trace)+1,len(mean_trace)/(timerange_lever[1]-timerange_lever[0])), 
           np.arange(timerange_lever[0], timerange_lever[1]+1,1, dtype=int),
           rotation=0)
plt.axhline(y=0, linestyle=':', color='black')
plt.axvline(x=len(mean_levertraces[0])/(timerange_lever[1]-timerange_lever[0])*(0-timerange_lever[0]),linewidth=1, color='black')
plt.ylabel('Z-score')
plt.title('Average Lever-aligned Trace with SEM by Session')
plt.legend()
plt.show()



#area under the curve
after_zero = 2
start_time = round(len(mean_traces[0])/(timerange_cue[1]-timerange_cue[0])*(0-timerange_cue[0]))
end_time = round(len(mean_traces[0])/(timerange_cue[1]-timerange_cue[0])*(after_zero-timerange_cue[0]))
area_under_curve = {}

for key, value in avgcuetrace_dict.items():
    mouse, session = key
    area = np.sum(value[start_time:end_time])
    if session not in area_under_curve:
        area_under_curve[session] = []
    area_under_curve[session].append((mouse, area))
plt.figure(figsize=(10, 6))
for session, data in area_under_curve.items():
    mice, areas = zip(*data)
    plt.scatter([session] * len(mice), areas, color=sns.color_palette("light:teal")[int(session)+1], label=f'Session {session}', alpha=0.7)
auc_df=pd.DataFrame()
for key, value in area_under_curve.items():
    for mouse, auc in value:
        auc_df.loc[key,mouse]=auc
plt.legend()
plt.xlabel('Session')
plt.ylabel('Area under the curve')
plt.title('Area under the curve from 0 to 2 sec')
plt.xticks(list(area_under_curve.keys()))
plt.tight_layout()
plt.show()

plt.figure(figsize=(12, 6))
totaltrace = np.array(df.iloc[:,2])
totaltracemean = np.mean(totaltrace)
totaltracestddev = np.std(totaltrace)
totaltracezscore = (totaltrace-totaltracemean)/totaltracestddev
multiplied_track_licks = [item * fs for item in track_licks]
multiplied_track_lever = [item * fs for item in track_lever]
multiplied_track_cue = [item * fs for item in track_cue]
multiplied_track_leverend = [item + 20*fs for item in multiplied_track_lever]
plt.plot(totaltracezscore)
plt.eventplot(multiplied_track_licks, colors='red', lineoffsets=0.5, label='lick')
plt.eventplot(multiplied_track_lever, colors='green', lineoffsets=0.5, label='leverpress/ sipper out')
plt.eventplot(multiplied_track_leverend, colors='blue', lineoffsets=0.5, label='end session')
plt.eventplot(multiplied_track_cue, colors='pink', lineoffsets=0.5, label='cue')
plt.legend()

############LICKS
#by session individual
plt.figure(figsize=(8,4))
for i in range(10):
    for mouse,session in avgflicktrace_dict:
        if session == i:
            plt.plot(avgflicktrace_dict[str(mouse),session],color=sns.color_palette("light:deeppink")[i],label=i)
plt.xticks(np.arange(0,len(zscore_flick[0])+1,len(zscore_flick[0])/(timerange_lick[1]-timerange_lick[0])), 
           np.arange(timerange_lick[0], timerange_lick[1]+1,1, dtype=int),
           rotation=0)
plt.axvline(x=len(zscore_flick[0])/(timerange_lick[1]-timerange_lick[0])*(0-timerange_lick[0]),linewidth=1, color='black')
plt.axhline(y=0, linestyle=':', color='black')
plt.legend()
plt.xlabel('First Lick Onset (s)')
plt.savefig('/Users/kristineyoon/Documents/lick.pdf', transparent=True)

#by session average
session_lickdata = {}  
for key, value in avgflicktrace_dict.items():
    mouse, session = key
    if session not in session_lickdata:
        session_lickdata[session] = []
    session_lickdata[session].append(value)
mean_licktraces = {}
sem_licktraces = {}
for session, traces in session_lickdata.items():
    mean_licktraces[session] = np.mean(traces, axis=0)
    sem_licktraces[session] = sem(traces)
plt.figure(figsize=(10, 6))
for session, mean_licktraces in mean_licktraces.items():
    sem_licktraces = sem_licktraces[session]
    plt.plot(mean_licktraces, color=sns.color_palette("light:deeppink")[int(session)+1], label=f'Session {session}')
    plt.fill_between(range(len(mean_licktraces)), mean_licktraces - sem_licktraces, mean_licktraces + sem_licktraces, color=sns.color_palette("light:deeppink")[int(session)+1], alpha=0.3)
plt.xlabel('Time (samples)')
plt.xticks(np.arange(0,len(mean_licktraces)+1,len(mean_licktraces)/(timerange_lick[1]-timerange_lick[0])), 
           np.arange(timerange_lick[0], timerange_lick[1]+1,1, dtype=int),
           rotation=0)
plt.axhline(y=0, linestyle=':', color='black')
plt.axvline(x=len(mean_licktraces)/(timerange_lick[1]-timerange_lick[0])*(0-timerange_lick[0]),linewidth=1, color='black')
plt.ylabel('Z-score')
plt.title('Average Lick-aligned Trace with SEM by Session')
plt.legend()
plt.show()


for key, value in lickbouttracedict.items():
    mouse, session, trial = key
    if trial == 0:
        plt.plot(lickbouttracedict[mouse, session, trial])

#by session average lick bouts
session_lickdata = {}  
for key, value in avglickbouttrace_dict.items():
    mouse, session = key
    if session not in session_lickdata:
        session_lickdata[session] = []
    session_lickdata[session].append(value)
mean_licktraces = {}
sem_licktraces = {}
for session, traces in session_lickdata.items():
    mean_licktraces[session] = np.mean(traces, axis=0)
    sem_licktraces[session] = sem(traces)
plt.figure(figsize=(10, 6))
for session, mean_licktraces in mean_licktraces.items():
    sem_licktraces = sem_licktraces[session]
    plt.plot(mean_licktraces, color=sns.color_palette("light:deeppink")[int(session)+1], label=f'Session {session}')
    plt.fill_between(range(len(mean_licktraces)), mean_licktraces - sem_licktraces, mean_licktraces + sem_licktraces, color=sns.color_palette("light:deeppink")[int(session)+1], alpha=0.3)
plt.xlabel('Time (samples)')
plt.xticks(np.arange(0,len(mean_licktraces)+1,len(mean_licktraces)/(timerange_lick[1]-timerange_lick[0])), 
           np.arange(timerange_lick[0], timerange_lick[1]+1,1, dtype=int),
           rotation=0)
plt.axhline(y=0, linestyle=':', color='black')
plt.axvline(x=len(mean_licktraces)/(timerange_lick[1]-timerange_lick[0])*(0-timerange_lick[0]),linewidth=1, color='black')
plt.ylabel('Z-score')
plt.title('Average Lick-aligned Trace with SEM by Session')
plt.legend()
plt.show()



#### LEVER ANALYSIS ####
plt.figure(figsize=(8,4))
for i in range(10):
    for mouse,session in avglevertrace_dict:
        if session == i:
            plt.plot(avglevertrace_dict[str(mouse),session],color=sns.color_palette("light:orange")[i],label=i)
plt.xticks(np.arange(0,len(zscore_lever[0])+1,len(zscore_lever[0])/(timerange_lever[1]-timerange_lever[0])), 
           np.arange(timerange_lever[0], timerange_lever[1]+1,1, dtype=int),
           rotation=0)
plt.axvline(x=len(zscore_lever[0])/(timerange_lever[1]-timerange_lever[0])*(0-timerange_lever[0]),linewidth=1, color='black')
plt.axhline(y=0, linestyle=':', color='black')
plt.legend()
plt.xlabel('Lever Onset (s)')
plt.savefig('/Users/kristineyoon/Documents/lever.pdf', transparent=True)

#### LICK ANALYSIS ####
plt.figure(figsize=(8,4))
for i in range(10):
    for mouse,session in avgflicktrace_dict:
        if session == i:
            plt.plot(avgflicktrace_dict[str(mouse),session],color=sns.color_palette("light:deeppink")[i],label=i)
plt.xticks(np.arange(0,len(zscore_cue[0])+1,len(zscore_cue[0])/(timerange_cue[1]-timerange_cue[0])), 
           np.arange(timerange_cue[0], timerange_cue[1]+1,1, dtype=int),
           rotation=0)
plt.axvline(x=len(zscore_cue[0])/(timerange_cue[1]-timerange_cue[0])*(0-timerange_cue[0]),linewidth=1, color='black')
plt.axhline(y=0, linestyle=':', color='black')
plt.legend()
plt.xlabel('First Lick Onset (s)')
plt.savefig('/Users/kristineyoon/Documents/lick.pdf', transparent=True)

#### RESPONSIVE ANALYSIS ####
#by session
plt.figure(figsize=(8,4))
for i in range(10):
    for mouse,session in avgresptrace_dict:
        if session == i:
            plt.plot(avgresptrace_dict[str(mouse),session],color=sns.color_palette("light:limegreen")[i],label=i)
plt.xticks(np.arange(0,len(zscore_cue[0])+1,len(zscore_cue[0])/(timerange_cue[1]-timerange_cue[0])), 
           np.arange(timerange_cue[0], timerange_cue[1]+1,1, dtype=int),
           rotation=0)
plt.axvline(x=len(zscore_cue[0])/(timerange_cue[1]-timerange_cue[0])*(0-timerange_cue[0]),linewidth=1, color='black')
plt.axhline(y=0, linestyle=':', color='black')
plt.legend()
plt.xlabel('Response Cue Onset (s)')
plt.savefig('/Users/kristineyoon/Documents/response.pdf', transparent=True)



######################## TO ALIGNMENT ##########################
align_to = []
timerange_to = [-2, 10]
for i in range(len(track_to)):
    lever_zero = round(track_to[i] * fs)
    lever_baseline = lever_zero + timerange_to[0] * fs
    lever_end = lever_zero + timerange_to[1] * fs
    trial = np.array(df.iloc[lever_baseline:lever_end,2])
    align_to.append(trial)

### DOWNSAMPLING
sample_to=[]
for lst in align_to: 
    small_lst = []
    for i in range(0, len(trial), N):
        small_lst.append(np.mean(lst[i:i+N-1])) # This is the moving window mean
    sample_to.append(small_lst)
    
zscore_to = []
baselinedict = {}
for i in range(len(sample_to)):
    trial = sample_to[i]
    zb = np.mean(trial[0:round((-timerange_to[0]*fs/N))])
    zsd = np.std(trial[0:round((-timerange_to[0]*fs/N))])
    baselinedict[track_to[i]] = zb, zsd
    trial = (trial - zb)/zsd
    zscore_to.append(trial)

#### ALIGN TO LEVER PRESS: AVERAGE LINE PLOT OF TRIALS ####
for i in range(len(zscore_to)):
plt.plot((zscore_to[0]), color=sns.color_palette("light:navy")[3])
plt.xticks(np.arange(0,len(zscore_to[0])+1,len(zscore_to[0])/(timerange_to[1]-timerange_to[0])), 
           np.arange(timerange_to[0], timerange_to[1]+1,1, dtype=int),
           rotation=0)
plt.axvline(x=len(zscore_to[0])/(timerange_to[1]-timerange_to[0])*(0-timerange_to[0]),linewidth=1, color='black')
plt.axhline(y=0, linestyle=':', color='black')
plt.xlabel('Lever Press Onset (s)')

# #by mouse
# for i in mice:
#     for mouse,session in avgcuetrace_dict:
# plt.figure(figsize=(8,4))
# for 
# plt.plot(np.mean(zscore_cue, axis=0), color='teal')
# plt.fill_between(np.arange(0,len(zscore_cue[0]),1),
#                 np.mean(zscore_cue, axis=0)+np.std(zscore_cue, axis=0), 
#                 np.mean(zscore_cue, axis=0)-np.std(zscore_cue, axis=0),
#                 facecolor='teal',
#                 alpha=0.2)
# plt.xticks(np.arange(0,len(zscore_cue[0])+1,len(zscore_cue[0])/(timerange_cue[1]-timerange_cue[0])), 
#            np.arange(timerange_cue[0], timerange_cue[1]+1,1, dtype=int),
#            rotation=0)
# plt.axvline(x=len(zscore_cue[0])/(timerange_cue[1]-timerange_cue[0])*(0-timerange_cue[0]),linewidth=1, color='black', label='Cue Onset')
# plt.axhline(y=0, linestyle=':', color='black')
# plt.xlabel('Cue Onset (s)')


# #PEAK HEIGHT IN THE FIRST SECOND
# calc_range = 1
# peakheight_df = pd.DataFrame()
# for i in range(0,10):
#     peakheight = max(fptrace_df[i][round((-timerange_cue[0])*fs/N):round((calc_range-timerange_cue[0])*fs/N)])
#     peakheight_df.loc[0,i]=peakheight




# #### GRAPHING ####
# plt.figure(figsize=(8,4))
# plt.plot(np.mean(respondingcue, axis=0), color='limegreen')
# plt.fill_between(np.arange(0,len(respondingcue[0]),1),
#                 np.mean(respondingcue, axis=0)+np.std(respondingcue, axis=0), 
#                 np.mean(respondingcue, axis=0)-np.std(respondingcue, axis=0),
#                 facecolor='limegreen',
#                 alpha=0.2)
# plt.xticks(np.arange(0,len(respondingcue[0])+1,len(respondingcue[0])/(timerange_cue[1]-timerange_cue[0])), 
#            np.arange(timerange_cue[0], timerange_cue[1]+1,1, dtype=int),
#            rotation=0)
# plt.axvline(x=len(respondingcue[0])/(timerange_cue[1]-timerange_cue[0])*(0-timerange_cue[0]),linewidth=1, color='black', label='Cue Onset')
# plt.axhline(y=0, linestyle=':', color='black')
# plt.xlabel('Cue Onset (s)')
# plt.ylim(-2,5)
# plt.tight_layout()
# plt.savefig('/Users/kristineyoon/Documents/response.pdf', transparent=True)



# #### GRAPHING ####
# plt.figure(figsize=(8,3))
# plt.plot(np.mean(nonrespondingcue, axis=0), color='limegreen')
# plt.fill_between(np.arange(0,len(nonrespondingcue[0]),1),
#                 np.mean(nonrespondingcue, axis=0)+np.std(nonrespondingcue, axis=0), 
#                 np.mean(nonrespondingcue, axis=0)-np.std(nonrespondingcue, axis=0),
#                 facecolor='limegreen',
#                 alpha=0.2)
# plt.xticks(np.arange(0,len(nonrespondingcue[0])+1,len(nonrespondingcue[0])/(timerange_cue[1]-timerange_cue[0])), 
#            np.arange(timerange_cue[0], timerange_cue[1]+1,1, dtype=int),
#            rotation=0)
# plt.axvline(x=len(nonrespondingcue[0])/(timerange_cue[1]-timerange_cue[0])*(0-timerange_cue[0]),linewidth=1, color='black', label='Cue Onset')
# plt.axhline(y=0, linestyle=':', color='black')
# plt.xlabel('Cue Onset (s)')
# plt.ylim(-2,5)
# plt.tight_layout()
# plt.savefig('/Users/kristineyoon/Documents/noresponse.pdf', transparent=True)

# ########################## LEVER PRESS ALIGNMENT ##########################
# align_lever = []
# timerange_lever = [-2, 5]
# for i in range(len(track_lever)):
#     lever_zero = round(track_lever[i] * fs)
#     lever_baseline = lever_zero + timerange_lever[0] * fs
#     lever_end = lever_zero + timerange_lever[1] * fs
#     trial = np.array(df.iloc[lever_baseline:lever_end,2])
#     align_lever.append(trial)

# ### DOWNSAMPLING
sample_lever=[]
for lst in align_lever: 
    small_lst = []
    for i in range(0, len(trial), N):
        small_lst.append(np.mean(lst[i:i+N-1])) # This is the moving window mean
    sample_lever.append(small_lst)
    
zscore_lever = []
for levertime, trace in zip(track_lever, sample_lever):
    for cue,lever in cuestolevers.items():
        if levertime == lever:
            zb = baselinedict[cue][0]
            zsd = baselinedict[cue][1]
            newtrial = (trace - zb)/zsd
            zscore_lever.append(newtrial)

#### ALIGN TO LEVER PRESS: AVERAGE LINE PLOT OF TRIALS ####
plt.plot(np.mean(zscore_lever, axis=0), color='orangered')
plt.fill_between(np.arange(0,len(zscore_lever[0]),1),
                 np.mean(zscore_lever, axis=0)+np.std(zscore_lever, axis=0), 
                np.mean(zscore_lever, axis=0)-np.std(zscore_lever, axis=0),
                facecolor='orangered',
                alpha=0.2)
plt.xticks(np.arange(0,len(zscore_lever[0])+1,len(zscore_lever[0])/(timerange_lever[1]-timerange_lever[0])), 
           np.arange(timerange_lever[0], timerange_lever[1]+1,1, dtype=int),
           rotation=0)
plt.axvline(x=len(zscore_lever[0])/(timerange_lever[1]-timerange_lever[0])*(0-timerange_lever[0]),linewidth=1, color='black', label='Lever Onset')
plt.axhline(y=0, linestyle=':', color='black')
plt.xlabel('Lever Press Onset (s)')


################## FIRST LICK ALIGNMENT ################3
track_flicks = []
firstlicks = []
for press in track_lever:
    lickyes = np.array(track_licks) > press
    firstlicktime = np.where(lickyes == True)
    if len(firstlicktime[0]) > 0:
        firstlicks.append(firstlicktime[0][0])
firstlicks = list(set(firstlicks))
for index in firstlicks:
    track_flicks.append(track_licks[index])

cuestolicks={}
for i in range(len(track_cue)):
    for k in range(len(track_flicks)):
        if track_flicks[k]- track_cue[i] <= (cue_time + lick_time) and track_flicks[k]- track_cue[i]>0:
            cuestolicks[track_cue[i]]=track_flicks[k]
            
align_flick = []
timerange_lick = [-2, 5]
for i in range(len(track_flicks)):
    flick_zero = round(track_flicks[i] * fs)
    flick_baseline = flick_zero + timerange_lick[0] * fs
    flick_end = flick_zero + timerange_lick[1] * fs
    trial = np.array(df.iloc[flick_baseline:flick_end,2])
    align_flick.append(trial)

### DOWNSAMPLING
sample_flick=[]
for lst in align_flick: 
    small_lst = []
    for i in range(0, len(lst), N):
        small_lst.append(np.mean(lst[i:i+N-1])) # This is the moving window mean
    sample_flick.append(small_lst)

zscore_flick = []
for flicktime, trace in zip(track_flicks, sample_flick):
    for cue,lick in cuestolicks.items():
        if flicktime == lick:
            zb = baselinedict[cue][0]
            zsd = baselinedict[cue][1]
            newtrial = (trace - zb)/zsd
            zscore_flick.append(newtrial)

#### ALIGN TO FIRSTLICK: AVERAGE LINE PLOT OF TRIALS ####
plt.plot(np.mean(zscore_flick, axis=0), color='deeppink')
plt.fill_between(np.arange(0,len(zscore_flick[0]),1),
                 np.mean(zscore_flick, axis=0)+np.std(zscore_flick, axis=0), 
                np.mean(zscore_flick, axis=0)-np.std(zscore_flick, axis=0),
                facecolor='deeppink',
                alpha=0.2)
plt.xticks(np.arange(0,len(zscore_flick[0])+1,len(zscore_flick[0])/(timerange_lick[1]-timerange_lick[0])), 
           np.arange(timerange_lick[0], timerange_lick[1]+1,1, dtype=int),
           rotation=0)
plt.axvline(x=len(zscore_flick[0])/(timerange_lick[1]-timerange_lick[0])*(0-timerange_lick[0]),linewidth=1, color='black')
plt.axhline(y=0, linestyle=':', color='black')
plt.xlabel('First Lick Onset (s)')

## AREA UNDER CURVE ##
auc_df = pd.DataFrame()
#cue
def trapezoidal_rule(x, y):
    area = 0.5 * sum((y[i] + y[i+1]) * ((x[i+1] - x[i])/(fs/N)) for i in range(len(x)-1))
    return area

timerange_auc = [0,2]
N = 10

auc_cue_range=[]
for i in range (len(zscore_cue)):
    trial = zscore_cue[i][int((timerange_auc[0]-timerange_cue[0])*(fs/N)):int((timerange_auc[1]-timerange_cue[0])*(fs/N))]
    auc_cue_range.append(trial)

auc_cue=[]
for i in range(len(auc_cue_range)):
    plt.plot(np.arange(0,len(auc_cue_range[i]),1),auc_cue_range[i])
    area = trapezoidal_rule(np.arange(0,len(auc_cue_range[i]),1), auc_cue_range[i])
    auc_cue.append(area)
    auc_df.at[i,'Cue'] = area
    
# responding cue
auc_respcue_range=[]
for i in range (len(respondingcue)):
    trial = respondingcue[i][int((timerange_auc[0]-timerange_cue[0])*(fs/N)):int((timerange_auc[1]-timerange_cue[0])*(fs/N))]
    auc_respcue_range.append(trial)

for i in range(len(auc_respcue_range)):
    plt.plot(np.arange(0,len(auc_respcue_range[i]),1),auc_respcue_range[i])
    area = trapezoidal_rule(np.arange(0,len(auc_respcue_range[i]),1), auc_respcue_range[i])
    print(area)
    auc_df.at[i,'Respond'] = area
    
# lever press
auc_levpress_range=[]
for i in range (len(zscore_lever)):
    trial = zscore_lever[i][len(zscore_lever[i])//2:]
    trial = trial[0:int(1*fs/N)]
    auc_levpress_range.append(trial)

for i in range(len(auc_levpress_range)):
    plt.plot(np.arange(0,len(auc_levpress_range[i]),1),auc_levpress_range[i])
    area = trapezoidal_rule(np.arange(0,len(auc_levpress_range[i]),1), auc_levpress_range[i])
    print(area/(fs/N))
    auc_df.at[i,'LeverPress'] = area/(fs/N)

# flick
auc_flick_range=[]
for i in range (len(zscore_flick)):
    trial = zscore_flick[i][len(zscore_flick[i])//2:]
    trial = trial[0:int(1*fs/N)]
    auc_flick_range.append(trial)

for i in range(len(auc_flick_range)):
    plt.plot(np.arange(0,len(auc_flick_range[i]),1),auc_flick_range[i])
    area = trapezoidal_rule(np.arange(0,len(auc_flick_range[i]),1), auc_flick_range[i])
    print(area/(fs/N))
    auc_df.at[i,'Lick'] = area/(fs/N)


#### PLOT EVERYTHING ALL TOGETHER ####
fig, axs = plt.subplots(2, 2, figsize=(8,6))
plt.suptitle(f'Recording {(np.where(np.array(files) == foi))[0][0]}')
    #### ALIGN TO CUE: AVERAGE LINE PLOT OF TRIALS ####
axs[0,0].plot(np.mean(nonrespondingcue, axis=0), color='teal')
axs[0,0].fill_between(np.arange(0,len(nonrespondingcue[0]),1),
                np.mean(nonrespondingcue, axis=0)+np.std(nonrespondingcue, axis=0), 
                np.mean(nonrespondingcue, axis=0)-np.std(nonrespondingcue, axis=0),
                facecolor='teal',
                alpha=0.2)
axs[0,0].title.set_text('Align to Cues')
axs[0,0].set_ylim([-5,6])
plt.sca(axs[0,0])
plt.xticks(np.arange(0,len(nonrespondingcue[0])+1,len(nonrespondingcue[0])/((timerange_cue[1]-timerange_cue[0]))), 
           np.arange(timerange_cue[0], timerange_cue[1]+1,1, dtype=int),
           rotation=0)
plt.axvline(x=len(nonrespondingcue[0])/(timerange_cue[1]-timerange_cue[0])*(0-timerange_cue[0]),linewidth=1, color='black', label='Cue Onset')
plt.axhline(y=0, linestyle=':', color='black')
plt.xlabel('Seconds from Cue Onset (s)')
fig.tight_layout(h_pad=0.5)
    #### ALIGN TO RESPONDING CUES ####
axs[0,1].plot(np.mean(respondingcue, axis=0), color='limegreen')
axs[0,1].fill_between(np.arange(0,len(respondingcue[0]),1),
                np.mean(respondingcue, axis=0)+np.std(respondingcue, axis=0), 
                np.mean(respondingcue, axis=0)-np.std(respondingcue, axis=0),
                facecolor='limegreen',
                alpha=0.2)
axs[0,1].title.set_text('Align to Responded Cues')
axs[0,1].set_ylim([-5,6])
plt.sca(axs[0,1])
plt.xticks(np.arange(0,len(respondingcue[0])+1,len(respondingcue[0])/(timerange_cue[1]-timerange_cue[0])), 
           np.arange(timerange_cue[0], timerange_cue[1]+1,1, dtype=int),
           rotation=0)
plt.axvline(x=len(respondingcue[0])/(timerange_cue[1]-timerange_cue[0])*(0-timerange_cue[0]),linewidth=1, color='black', label='Cue Onset')
plt.axhline(y=0, linestyle=':', color='black')
plt.xlabel('Seconds from Cue Onset (s)')
fig.tight_layout(h_pad=0.5)
    #### ALIGN TO LEVER PRESS: AVERAGE LINE PLOT OF TRIALS ####
axs[1,0].plot(np.mean(zscore_lever, axis=0), color='orangered')
axs[1,0].fill_between(np.arange(0,len(zscore_lever[0]),1),
                 np.mean(zscore_lever, axis=0)+np.std(zscore_lever, axis=0), 
                np.mean(zscore_lever, axis=0)-np.std(zscore_lever, axis=0),
                facecolor='orangered',
                alpha=0.2)
axs[1,0].title.set_text('Align to Lever Presses')
axs[1,0].set_ylim([-5,6])
plt.sca(axs[1,0])
plt.xticks(np.arange(0,len(zscore_lever[0])+1,len(zscore_lever[0])/(timerange_lever[1]-timerange_lever[0])), 
           np.arange(timerange_lever[0], timerange_lever[1]+1,1, dtype=int),
           rotation=0)
plt.axvline(x=len(zscore_lever[0])/(timerange_lever[1]-timerange_lever[0])*(0-timerange_lever[0]),linewidth=1, color='black', label='Lever Onset')
plt.axhline(y=0, linestyle=':', color='black')
plt.xlabel('Seconds from Lever Press Onset (s)')
fig.tight_layout(h_pad=0.5)
    #### ALIGN TO FIRSTLICK: AVERAGE LINE PLOT OF TRIALS ####
axs[1,1].plot(np.mean(zscore_flick, axis=0), color='deeppink')
axs[1,1].fill_between(np.arange(0,len(zscore_flick[0]),1),
                 np.mean(zscore_flick, axis=0)+np.std(zscore_flick, axis=0), 
                np.mean(zscore_flick, axis=0)-np.std(zscore_flick, axis=0),
                facecolor='deeppink',
                alpha=0.2)
axs[1,1].title.set_text('Align to First Licks')
axs[1,1].set_ylim([-5,6])
plt.sca(axs[1,1])
plt.xticks(np.arange(0,len(zscore_flick[0])+1,len(zscore_flick[0])/(timerange_lick[1]-timerange_lick[0])), 
           np.arange(timerange_lick[0], timerange_lick[1]+1,1, dtype=int),
           rotation=0)
plt.axvline(x=len(zscore_flick[0])/(timerange_lick[1]-timerange_lick[0])*(0-timerange_lick[0]),linewidth=1, color='black')
plt.axhline(y=0, linestyle=':', color='black')
plt.xlabel('Seconds from First Lick Onset (s)')
fig.tight_layout(h_pad=0.5)

plt.savefig('/Users/kristineyoon/Documents/all curves.pdf', transparent=True)

######### INDIVIDUAL TRACES IN THE TRIALS WITH CUE-LEVER-LICK ######### 
align_cue = []
timerange_cue = [-5, 20]
for i in range(len(track_cue)):
    cue_zero = round(track_cue[i] * fs)
    cue_baseline = cue_zero + timerange_cue[0] * fs
    cue_end = cue_zero + timerange_cue[1] * fs
    trial = np.array(df.iloc[cue_baseline:cue_end,2])
    align_cue.append(trial)
        
### DOWNSAMPLING
sample_cue=[]
for lst in align_cue: 
    small_lst = []
    for i in range(0, len(trial), N):
        small_lst.append(np.mean(lst[i:i+N-1])) # This is the moving window mean
    sample_cue.append(small_lst)
    
zscore_cue = []

baselinedict = {}
for i in range(len(sample_cue)):
    trial = sample_cue[i]
    zb = np.mean(trial[0:round((-timerange_cue[0]*fs/N))])
    zsd = np.std(trial[0:round((-timerange_cue[0]*fs/N))])
    baselinedict[track_cue[i]] = zb, zsd
    trial = (trial - zb)/zsd
    zscore_cue.append(trial)

zscoreindex=[]
for i in range (len(track_cue)):
    truefalse = np.where(track_cue[i] in cuestolicks.keys(), True, False)
    zscoreindex.append(truefalse)
    
selectcuetrials = []
for i in range(len(zscoreindex)):
    if zscoreindex[i] == True:
        selectcuetrials.append(zscore_cue[i])
        
leverlatencytocue=[]
licklatencytocue=[]
for i in range(len(track_cue)):
    for k in range(len(track_lever)):
        for j in range(len(track_flicks)):
            if track_lever[k]- track_cue[i] <= cue_time and track_lever[k]- track_cue[i]>0 and track_flicks[j]- track_cue[i] <= (cue_time + lick_time) and track_flicks[j]- track_cue[i]>0:
                leverlatencytocue.append(track_lever[k]- track_cue[i])
                licklatencytocue.append(track_flicks[j]- track_cue[i])
            
ntrials = len(zscore_flick)

fig, axs = plt.subplots(ntrials, 1, figsize=(12,ntrials*2))
all_axes = fig.get_axes()
for ax in all_axes:
    for sp in ax.spines.values():
        sp.set_visible(False)
    ax.tick_params(left=False, bottom=False, labelbottom=False, labelleft=False)

for i in range(0,ntrials):
    axs[i] = fig.add_subplot(ntrials,1,i+1)
    axs[i].axvline(x=0, linewidth=3, color='teal', label='Cue', alpha=0.6)
    axs[i].axvline(x=leverlatencytocue[i], linewidth=3, color='orangered', label='Lever', alpha=0.6)
    axs[i].axvline(x=licklatencytocue[i], linewidth=3, color='deeppink', label='First Lick', alpha=0.6)
    axs[i].legend(loc='upper right')
    axs_time = np.linspace(timerange_cue[0], timerange_cue[1], len(selectcuetrials[i]))
    axs[i].plot(axs_time, np.array(selectcuetrials[i]), linewidth=2, color = 'cornflowerblue')
    axs[i].axhline(y=0, linewidth=1, linestyle=':', color='black')
    axs[i].set_ylabel(f'Trial {i} \n\n z-Score', labelpad = 1)
    axs[i].set_xlabel('seconds')
    axs[i].set_xlim(timerange_cue[0], timerange_cue[1])
    axs[i].set_xticks(np.arange(timerange_cue[0], timerange_cue[1]+1,1, dtype=int))
    axs[i].set_ylim(-5,8)
plt.suptitle(f'Recording {(np.where(np.array(files) == foi))[0][0]}')
fig.tight_layout(h_pad=0.45)
plt.savefig('/Users/kristineyoon/Documents/trialbytrial.pdf', transparent=True)



# ########################## CUE ALIGNMENT ##########################    
        
# cuestolevers={}
# for i in range(len(track_cue)):
#     for k in range(len(track_lever)):
#         if track_lever[k]- track_cue[i]<= cue_time and track_lever[k]- track_cue[i]>0:
#             cuestolevers[track_cue[i]]=track_lever[k]
            
# from scipy.signal import find_peaks           
# signalaftercue = []

# timerange_cue = [-5, 10]
# for i in range(len(track_cue)):
#     cue_zero = round(track_cue[i] * fs)
#     cue_baseline = cue_zero + timerange_cue[0] * fs
#     cue_end = cue_zero + timerange_cue[1] * fs
#     trial = np.array(df.iloc[cue_baseline:cue_end,2])
#     signalaftercue = np.array(df.iloc[cue_zero:cue_end,2])
#     peaks, properties = find_peaks(signalaftercue, width=100)
#     plt.plot(signalaftercue)
#     plt.plot(peaks[0],signalaftercue[peaks[0]], "x")
#     print(peaks)
# print (signalaftercue)
        
# ### DOWNSAMPLING
# N = 10
# sample_cue=[]
# for lst in align_cue: 
#     small_lst = []
#     for i in range(0, len(trial), N):
#         small_lst.append(np.mean(lst[i:i+N-1])) # This is the moving window mean
#     sample_cue.append(small_lst)
    
# zscore_cue = []

# baselinedict = {}
# for i in range(len(sample_cue)):
#     trial = sample_cue[i]
#     zb = np.mean(trial[0:round((-timerange_cue[0]*fs/N))])
#     zsd = np.std(trial[0:round((-timerange_cue[0]*fs/N))])
#     baselinedict[track_cue[i]] = zb, zsd
#     trial = (trial - zb)/zsd
#     zscore_cue.append(trial)


# #### ALIGN TO CUE: AVERAGE LINE PLOT OF TRIALS ####
# plt.plot(np.mean(zscore_cue, axis=0), color='teal')
# plt.fill_between(np.arange(0,len(zscore_cue[0]),1),
#                 np.mean(zscore_cue, axis=0)+np.std(zscore_cue, axis=0), 
#                 np.mean(zscore_cue, axis=0)-np.std(zscore_cue, axis=0),
#                 facecolor='teal',
#                 alpha=0.2)
# plt.xticks(np.arange(0,len(zscore_cue[0])+1,len(zscore_cue[0])/(timerange_cue[1]-timerange_cue[0])), 
#            np.arange(timerange_cue[0], timerange_cue[1]+1,1, dtype=int),
#            rotation=0)
# plt.axvline(x=len(zscore_cue[0])/(timerange_cue[1]-timerange_cue[0])*(0-timerange_cue[0]),linewidth=1, color='black', label='Cue Onset')
# plt.axhline(y=0, linestyle=':', color='black')
# plt.xlabel('Cue Onset (s)')
    
# ### ALIGN TO FIRST PEAK AFTER CUE ###

# zscore_cuepeak = []
# baselinedict_alignpeakcue = {}
# for i in range(len(sample_cue)):
#     trial = sample_cue[i]
#     zb = np.mean(trial[0:round((-timerange_cue[0]*fs/N))])
#     zsd = np.std(trial[0:round((-timerange_cue[0]*fs/N))])
#     baselinedict_alignpeakcue[track_cue[i]] = zb, zsd
#     trial = (trial - zb)/zsd
#     zscore_cue.append(trial)

    
    
    
####################################################
####################################################
####################################################
####################################################
####################################################
####################################################
####################################################
####################################################
# ########################## ADD LATENCY ##########################
# cue_time = 30
# lick_time= 10

# track_cue = []
# track_lever = []
# track_licks  =[]
# latency= []
# leverpermice = []
# for i in range(len(fp_df)):
#     if fp_df.iloc[i,0] == 'Cue':
#         track_cue.append(fp_df.iloc[i,1])
#     if fp_df.iloc[i,0] == 'Press':
#         track_lever.append(fp_df.iloc[i,1])
#     if fp_df.iloc[i,0] == 'Licks':
#         track_licks.append(fp_df.iloc[i,1])

# lever_latency = {}
# for i in range(len(track_cue)):
#     lever_list=[]
#     for k in range (len(track_lever)):
#         if track_lever[k] - track_cue[i] <= cue_time and track_lever[k] - track_cue[i] > 0:
#             lever_list.append(track_lever[k] - track_cue[i])
#         lever_latency[i] = lever_list
# lick_latency = {}
# for i in range(len(lever_latency)):
#     lick_list = []
#     if len(lever_latency[i]) != 0:
#         for k in range (len(track_licks)):
#             if track_licks[k] - track_cue[i] <= cue_time and track_licks[k] - track_cue[i] > 0:
#                 lick_list.append(track_licks[k] - track_cue[i])
#             lick_latency[i] = lick_list
#     else:
#         lick_latency[i] = []

# df_lever = pd.Series(lever_latency)
# df_lick = pd.Series(lick_latency)

  
# ########################## INDIVIDUAL TRIAL TRACES TO CUE ##########################
# ntrials = len(zscore_cue)
# colors = sns.color_palette("tab20")
# listall = []
# graphit = 0

# fig, axs = plt.subplots(ntrials, 1, figsize=(12,ntrials))
# all_axes = fig.get_axes()
# for ax in all_axes:
#     for sp in ax.spines.values():
#         sp.set_visible(False)
#     ax.tick_params(left=False, bottom=False, labelbottom=False, labelleft=False)

# for i in range(0,ntrials):
    
#     axs[i] = fig.add_subplot(ntrials,1,i+1)
#     axs_time = np.linspace(timerange_cue[0], timerange_cue[1], len(zscore_cue[i]))
#     axs[i].axvline(x=0, linewidth=1, color='black')
#     axs[i].axhline(y=0, linewidth=1, color='lightgrey')
#     if i < 20:
#         axs[i].plot(axs_time, np.array(zscore_cue[i]), linewidth=2, color=colors[i])
#     else:
#         axs[i].plot(axs_time, np.array(zscore_cue[i]), linewidth=2, color=colors[round(i-20)])
#     axs[i].set_ylabel('z-Score', labelpad = 2)
#     axs[i].set_xlim(timerange_cue[0], timerange_cue[1])
#     axs[i].set_xticks(np.arange(timerange_cue[0], timerange_cue[1]+1,1, dtype=int))
#     axs[i].set_ylim(-5,15)

# fig.tight_layout(h_pad=0.45)

  
# ########################## INDIVIDUAL TRIAL TRACES TO LEVER ##########################
# ntrials = len(zscore_lever)
# colors = sns.color_palette("tab20")
# listall = []
# graphit = 0

# df_all = pd.DataFrame(columns=["Lever","Lick"])
# for i in range(0,ntrials):
#     df_all.loc[i]=[df_lever.iloc[i], df_lick.iloc[i]]

# fig, axs = plt.subplots(ntrials, 1, figsize=(12,ntrials))
# all_axes = fig.get_axes()
# for ax in all_axes:
#     for sp in ax.spines.values():
#         sp.set_visible(False)
#     ax.tick_params(left=False, bottom=False, labelbottom=False, labelleft=False)

# for i in range(0,ntrials):
    
#     axs[i] = fig.add_subplot(ntrials,1,i+1)
#     axs_time = np.linspace(timerange_lever[0], timerange_lever[1], len(zscore_lever[i]))
#     axs[i].axvline(x=0, linewidth=1, color='black')
#     axs[i].axhline(y=0, linewidth=1, color='lightgrey')
#     if i < 20:
#         axs[i].plot(axs_time, np.array(zscore_lever[i]), linewidth=2, color=colors[i])
#     else:
#         axs[i].plot(axs_time, np.array(zscore_lever[i]), linewidth=2, color=colors[round(i-20)])
#     axs[i].set_ylabel('z-Score', labelpad = 2)
#     axs[i].set_xlim(timerange_lever[0], timerange_lever[1])
#     axs[i].set_xticks(np.arange(timerange_lever[0], timerange_lever[1]+1,1, dtype=int))
#     axs[i].set_ylim(-5,5)

# fig.tight_layout(h_pad=0.45)

#### TRIALS ON HEATMAP ALIGNED TO CUE ####
plt.figure(figsize=(5,3))
sns.heatmap(zscore_cue, cmap='RdBu', vmin=-5, vmax=5, cbar_kws={'label': 'Delta F/F From Baseline'})
plt.xticks(np.arange(0,len(zscore_cue[0])+1,len(zscore_cue[0])/(timerange_cue[1]-timerange_cue[0])), 
            np.arange(timerange_cue[0], timerange_cue[1]+1,1, dtype=int),
            rotation=0)
plt.axvline(x=len(zscore_cue[0])/(timerange_cue[1]-timerange_cue[0])*(0-timerange_cue[0]),linewidth=1, color='black', label='Cue Onset')
plt.ylabel('Trials')
plt.xlabel('Cue Onset')


#### TRIALS ON HEATMAP ALIGNED TO LEVERPRESS ####
plt.figure(figsize=(5,3))
sns.heatmap(zscore_lever, cmap='RdBu', vmin=-5, vmax=5, cbar_kws={'label': 'Delta F/F From Baseline'})
plt.xticks(np.arange(0,len(zscore_lever[0])+1,len(zscore_lever[0])/(timerange_lever[1]-timerange_lever[0])), 
            np.arange(timerange_lever[0], timerange_lever[1]+1,1, dtype=int),
            rotation=0)
plt.axvline(x=len(zscore_lever[0])/(timerange_lever[1]-timerange_lever[0])*(0-timerange_lever[0]),linewidth=1, color='black', label='Lever Onset')
plt.ylabel('Trials')
plt.xlabel('Lever Press Onset')

#### TRIALS ON HEATMAP ALIGNED TO LEVERPRESS ####
plt.figure(figsize=(5,3))
sns.heatmap(zscore_flick, cmap='RdBu', vmin=-5, vmax=5, cbar_kws={'label': 'Delta F/F From Baseline'})
plt.xticks(np.arange(0,len(zscore_flick[0])+1,len(zscore_flick[0])/(timerange_lever[1]-timerange_lever[0])), 
            np.arange(timerange_lever[0], timerange_lever[1]+1,1, dtype=int),
            rotation=0)
plt.axvline(x=len(zscore_flick[0])/(timerange_lever[1]-timerange_lever[0])*(0-timerange_lever[0]),linewidth=1, color='black', label='Lever Onset')
plt.ylabel('Trials')
plt.xlabel('Lever Press Onset')

# #### ALIGN TO CUE: AVERAGE LINE PLOT OF TRIALS ####
# plt.plot(np.mean(zscore_cue, axis=0), color='blue')
# plt.fill_between(np.arange(0,len(zscore_cue[0]),1),
#                 np.mean(zscore_cue, axis=0)+np.std(zscore_cue, axis=0), 
#                 np.mean(zscore_cue, axis=0)-np.std(zscore_cue, axis=0),
#                 facecolor='blue',
#                 alpha=0.2)
# plt.xticks(np.arange(0,len(zscore_cue[0])+1,len(zscore_cue[0])/(timerange_cue[1]-timerange_cue[0])), 
#            np.arange(timerange_cue[0], timerange_cue[1]+1,1, dtype=int),
#            rotation=0)
# plt.axvline(x=len(zscore_cue[0])/(timerange_cue[1]-timerange_cue[0])*(0-timerange_cue[0]),linewidth=1, color='black', label='Cue Onset')
# plt.xlabel('Cue Onset')

# #### ALIGN TO LEVER PRESS: AVERAGE LINE PLOT OF TRIALS ####
# plt.plot(np.mean(zscore_lever, axis=0), color='orange')
# plt.fill_between(np.arange(0,len(zscore_lever[0]),1),
#                  np.mean(zscore_lever, axis=0)+np.std(zscore_lever, axis=0), 
#                 np.mean(zscore_lever, axis=0)-np.std(zscore_lever, axis=0),
#                 facecolor='orange',
#                 alpha=0.2)
# plt.xticks(np.arange(0,len(zscore_lever[0])+1,len(zscore_lever[0])/(timerange_lever[1]-timerange_lever[0])), 
#            np.arange(timerange_lever[0], timerange_lever[1]+1,1, dtype=int),
#            rotation=0)
# plt.axvline(x=len(zscore_lever[0])/(timerange_lever[1]-timerange_lever[0])*(0-timerange_lever[0]),linewidth=1, color='black', label='Lever Onset')
# plt.xlabel('Lever Press Onset')


# #### RASTER PLOT OF EACH TRIAL ####
# fig, axs = plt.subplots(ntrials, 1, figsize=(12,ntrials))
# all_axes = fig.get_axes()
# for ax in all_axes:
#     for sp in ax.spines.values():
#         sp.set_visible(False)
#     ax.tick_params(left=False, bottom=False, labelbottom=False, labelleft=False)

# for i in range(0,ntrials):
#     axs[i] = fig.add_subplot(ntrials,1,i+1)
#     axs[i].eventplot(df_all.loc[i], colors=['black','red'], lineoffsets=[0,0])
#     axs[i].set_ylabel('Events', labelpad = 2)
#     axs[i].set_xticks(np.arange(timerange_cue[0], timerange_cue[1]+1,1, dtype=int))
#     axs[i].set(xlim=(timerange_cue[0], timerange_cue[1]), 
#                ylim=(-1,1))

# fig.tight_layout(h_pad=0.45)

######################################

# axs[4].eventplot(cue_df, colors='black', lineoffsets=leveroff)
# axs[4].set(xlim=(timerange_cue[0], timerange_cue[1]), 
#            ylim=(len(cue_df),0), 
#            yticks=np.arange(0.5,len(cue_df)+0.5))

# axs[5] = axs[2].twinx()
# lickoff = np.arange(0.5,len(lever_df)+0.5)
# axs[5].eventplot(lever_df, colors='black', lineoffsets=lickoff)
# axs[5].set(xlim=(timerange_lever[0], timerange_lever[1]), 
#            ylim=(len(lever_df),0), 
#            yticks=np.arange(0.5,len(lever_df)+0.5))



# lever_latency = sorted(lever_latency.items(), key=lambda x:x[1])
# lick_latency = sorted(lick_latency.items(), key=lambda x:x[1])

# ########################## SPLIT DATA TO RESPONSE V. NONRESPONSE ##########################
# response_cue = []
# nonresponse_cue = []
# for key,value in lever_latency:
#     if len(value) == 0:
#         nonresponse_cue.append(zscore_cue[key])
#     else:
#         response_cue.append(zscore_cue[key])

# ########################## CONVERTING LATENCY DATA TO DATAFRAMES ##########################

# rp_response = []
# for key,value in lever_latency:
#     if len(value) != 0:
#         rp_response.append(value)

# cue_df = pd.Series(rp_response)
# lever_df = pd.Series(rp_lick)

#####################################################################################################
################################## PLOTTING HEATMAP WITH EVENTPLOT ##################################
#####################################################################################################


# heightratio = [len(response_cue),len(nonresponse_cue), len(sorted_lick), len(zscore_lick), 0, 0]
# fig, axs = plt.subplots(6, 1, figsize=(12,20), gridspec_kw={'height_ratios':heightratio})
# all_axes = fig.get_axes()
# for ax in all_axes:
#     for sp in ax.spines.values():
#         sp.set_visible(False)
#     ax.tick_params(left=False, bottom=False, labelbottom=False, labelleft=False)
# fig.tight_layout(h_pad=0.8)

# axs[0] = fig.add_subplot(6,1,1)
# heatmap_rescue = axs[0].imshow(response_cue, 
#                 cmap='RdBu', 
#                 vmin = -3, vmax = 3, 
#                 interpolation='none', aspect="auto",
#                 extent=[timerange_cue[0], timerange_cue[1], len(response_cue), 0])
# cbar = fig.colorbar(heatmap_rescue, pad=0.08, fraction=0.02)
# axs[0].axvline(x=0, linewidth=2, color='black', label='Cue Onset')
# axs[0].set_ylabel('Trials')
# axs[0].set_xlabel('Seconds from Cue Onset (Responsive)')
# cbar.ax.set_ylabel('Delta F/F From Baseline', rotation=90)
# axs[0].set_xticks(np.arange(timerange_cue[0], timerange_cue[1]+1,1, dtype=int))
# axs[0].set_yticks(np.arange(0, len(response_cue)+1,1, dtype=int))

# axs[1] = fig.add_subplot(6,1,2)
# heatmap_norescue = axs[1].imshow(nonresponse_cue, 
#                 cmap='RdBu', 
#                 vmin = -3, vmax = 3, 
#                 interpolation='none', aspect="auto",
#                 extent=[timerange_cue[0], timerange_cue[1], len(nonresponse_cue), 0])
# cbar = fig.colorbar(heatmap_norescue, pad=0.08, fraction=0.02)
# axs[1].axvline(x=0, linewidth=2, color='black', label='Cue Onset')
# axs[1].set_ylabel('Trials')
# axs[1].set_xlabel('Seconds from Cue Onset (No Lever Press)')
# cbar.ax.set_ylabel('Delta F/F From Baseline', rotation=90)
# axs[1].set_xticks(np.arange(timerange_cue[0], timerange_cue[1]+1,1, dtype=int))
# axs[1].set_yticks(np.arange(0, len(nonresponse_cue)+1,1, dtype=int))

# axs[2] = fig.add_subplot(6,1,3)
# heatmap_lever = axs[2].imshow(sorted_lick, 
#                 cmap='RdBu', 
#                 vmin = -3, vmax = 3, 
#                 interpolation='none', aspect="auto",
#                 extent=[timerange_lever[0], timerange_lever[1], len(sorted_lick), 0])
# cbar = fig.colorbar(heatmap_lever, pad=0.08, fraction=0.02)
# axs[2].axvline(x=0, linewidth=2, color='black', label='Lever Onset')
# axs[2].set_ylabel('Trials')
# axs[2].set_xlabel('Seconds from Lever Onset')
# cbar.ax.set_ylabel('Delta F/F From Baseline', rotation=90)
# axs[2].set_xticks(np.arange(timerange_lever[0], timerange_lever[1]+1,1, dtype=int))
# axs[2].set_yticks(np.arange(0, len(sorted_lick)+1,1, dtype=int))
 
# axs[3] = fig.add_subplot(6,1,4)
# heatmap_flick = axs[3].imshow(zscore_lick, 
#                 cmap='RdBu', 
#                 vmin = -3, vmax = 3, 
#                 interpolation='none', aspect="auto",
#                 extent=[timerange_lick[0], timerange_lick[1], len(zscore_lick), 0])
# cbar = fig.colorbar(heatmap_flick, pad=0.08, fraction=0.02)
# axs[3].axvline(x=0, linewidth=2, color='black', label='Lick Onset')
# axs[3].set_ylabel('Trials')
# axs[3].set_xlabel('Seconds from First Lick Onset')
# cbar.ax.set_ylabel('Delta F/F From Baseline', rotation=90)
# axs[3].set_xticks(np.arange(timerange_lick[0], timerange_lick[1]+1,1, dtype=int))
# axs[3].set_yticks(np.arange(0, len(zscore_lick)+1,1, dtype=int))

# fig.tight_layout(h_pad=0.45)

# axs[4] = axs[0].twinx()
# leveroff = np.arange(0.5,len(cue_df)+0.5)
# axs[4].eventplot(cue_df, colors='black', lineoffsets=leveroff)
# axs[4].set(xlim=(timerange_cue[0], timerange_cue[1]), 
#            ylim=(len(cue_df),0), 
#            yticks=np.arange(0.5,len(cue_df)+0.5))

# axs[5] = axs[2].twinx()
# lickoff = np.arange(0.5,len(lever_df)+0.5)
# axs[5].eventplot(lever_df, colors='black', lineoffsets=lickoff)
# axs[5].set(xlim=(timerange_lever[0], timerange_lever[1]), 
#            ylim=(len(lever_df),0), 
#            yticks=np.arange(0.5,len(lever_df)+0.5))

# #####################################################################################################
# #####################################################################################################
# #####################################################################################################
# ###################################### PLOTTING AVG LINE PLOTS ######################################
# #####################################################################################################
# #####################################################################################################
# #####################################################################################################

# fig, axs = plt.subplots(4,1,figsize=(10,20))
# all_axes = fig.get_axes()
# for ax in all_axes:
#     for sp in ax.spines.values():
#         sp.set_visible(False)
#     ax.tick_params(left = False, bottom = False, labelbottom=False, labelleft=False)

# axs[0] = fig.add_subplot(4,1,1)
# axs0_time = np.linspace(timerange_cue[0], timerange_cue[1], int(len(align_cue[0])/sample))
# axs[0].plot(axs0_time, np.mean(response_cue, axis=0), linewidth=2, color='orange')
# axs[0].fill_between(axs0_time, np.mean(response_cue, axis=0)+np.std(response_cue)
#                       ,np.mean(response_cue, axis=0)-np.std(response_cue), facecolor='orange', alpha=0.2)
# axs[0].axvline(x=0, linewidth=2, color='black', label='Cue Onset')
# axs[0].set_xlabel('Seconds from Cue Onset (Responsive)')
# axs[0].set_ylabel('z-Score', labelpad = 2)
# axs[0].set_xlim(timerange_cue[0], timerange_cue[1])
# axs[0].set_xticks(np.arange(timerange_cue[0], timerange_cue[1]+1,1, dtype=int))
# axs[0].set_ylim(-3, 3)

# axs[1] = fig.add_subplot(4,1,2)
# axs1_time = np.linspace(timerange_cue[0], timerange_cue[1], int(len(align_cue[0])/sample))
# axs[1].plot(axs1_time, np.mean(nonresponse_cue, axis=0), linewidth=2, color='gold')
# axs[1].fill_between(axs1_time, np.mean(nonresponse_cue, axis=0)+np.std(nonresponse_cue)
#                       ,np.mean(response_cue, axis=0)-np.std(response_cue), facecolor='gold', alpha=0.2)
# axs[1].axvline(x=0, linewidth=2, color='black', label='Cue')
# axs[1].set_xlabel('Seconds from Cue Onset (No Lever Press)')
# axs[1].set_ylabel('z-Score', labelpad = 2)
# axs[1].set_xlim(timerange_cue[0], timerange_cue[1])
# axs[1].set_xticks(np.arange(timerange_cue[0], timerange_cue[1]+1,1, dtype=int))
# axs[1].set_ylim(-3, 3)

# axs[2] = fig.add_subplot(4,1,3)
# axs2_time = np.linspace(timerange_lever[0], timerange_lever[1], int(len(align_lever[0])/sample))
# axs[2].plot(axs2_time, np.mean(zscore_lever, axis=0), linewidth=2, color='teal')
# axs[2].fill_between(axs2_time, np.mean(zscore_lever, axis=0)+np.std(zscore_lever)
#                       ,np.mean(zscore_lever, axis=0)-np.std(zscore_lever), facecolor='teal', alpha=0.2)
# axs[2].axvline(x=0, linewidth=2, color='black', label='Lever')
# axs[2].set_xlabel('Seconds from Lever Onset')
# axs[2].set_ylabel('z-Score', labelpad = 2)
# axs[2].set_xlim(timerange_lever[0], timerange_lever[1])
# axs[2].set_xticks(np.arange(timerange_lever[0], timerange_lever[1]+1,1, dtype=int))
# axs[2].set_ylim(-3, 3)

# axs[3] = fig.add_subplot(4,1,4)
# axs3_time = np.linspace(timerange_lick[0], timerange_lick[1], int(len(align_lick[0])/sample))
# axs[3].plot(axs3_time, np.mean(zscore_lick, axis=0), linewidth=2, color='indigo')
# axs[3].fill_between(axs3_time, np.mean(zscore_lick, axis=0)+np.std(zscore_lick)
#                       ,np.mean(zscore_lick, axis=0)-np.std(zscore_lick), facecolor='indigo', alpha=0.2)
# axs[3].axvline(x=0, linewidth=2, color='black', label='First Lick')
# axs[3].set_xlabel('Seconds from First Lick Onset')
# axs[3].set_ylabel('z-Score', labelpad = 2)
# axs[3].set_xlim(timerange_lick[0], timerange_lick[1])
# axs[3].set_xticks(np.arange(timerange_lick[0], timerange_lick[1]+1,1, dtype=int))
# axs[3].set_ylim(-3, 3)
